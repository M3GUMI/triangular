Index: lib/pathfinder/graph.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <cfloat>\r\n#include \"graph.h\"\r\n#include <sys/timeb.h>\r\n#include <sys/time.h>\r\n\r\nnamespace Pathfinder{\r\n    Graph::Graph(HttpWrapper::BinanceApiWrapper &apiWrapper): apiWrapper(apiWrapper) {\r\n    }\r\n    Graph::~Graph() = default;\r\n\r\n    void Graph::Init(vector<HttpWrapper::BinanceSymbolData> &data)\r\n    {\r\n        tokenToIndex.clear();\r\n        indexToToken.clear();\r\n        triangularMap.clear();\r\n        pathMap.clear();\r\n        relatedTriangular.clear();\r\n        relatedPath.clear();\r\n        bestPathMap.clear();\r\n\r\n        // 初始化index\r\n        int indexCount = 0;\r\n        for (auto& item : data)\r\n        {\r\n            if (not tokenToIndex.count(item.BaseToken)) {\r\n                tokenToIndex[item.BaseToken] = indexCount;\r\n                indexToToken[indexCount] = item.BaseToken;\r\n                indexCount++;\r\n            }\r\n\r\n            if (not tokenToIndex.count(item.QuoteToken)) {\r\n                tokenToIndex[item.QuoteToken] = indexCount;\r\n                indexToToken[indexCount] = item.QuoteToken;\r\n                indexCount++;\r\n            }\r\n        }\r\n\r\n        // 初始化交易节点\r\n        for (auto& item : data)\r\n        {\r\n            auto baseIndex = tokenToIndex[item.BaseToken];\r\n            auto quoteIndex = tokenToIndex[item.QuoteToken];\r\n\r\n            auto tradeNode = new Node(baseIndex, quoteIndex);\r\n            this->tradeNodeMap[formatKey(baseIndex, quoteIndex)] = tradeNode;\r\n            this->tradeNodeMap[formatKey(quoteIndex, baseIndex)] = tradeNode;\r\n        }\r\n\r\n        // 存储所有三元环\r\n        for (const auto &baseToken: conf::BaseAssets)\r\n        {\r\n            if (not tokenToIndex.count(baseToken.first))\r\n            {\r\n                spdlog::error(\"func: Graph::init, msg: baseAsset not exist\");\r\n                continue;\r\n            };\r\n\r\n            auto originIndex = tokenToIndex[baseToken.first]; // 起点token\r\n            for (const auto& second : indexToToken)\r\n            {\r\n                auto secondIndex = second.first; // 第一个点\r\n                if (not tradeNodeMap.count(formatKey(originIndex, secondIndex))) {\r\n                    // 第一条边不存在\r\n                    continue;\r\n                }\r\n\r\n                for (const auto& third : indexToToken)\r\n                {\r\n                    auto thirdIndex = third.first; // 第二个点\r\n                    if (not tradeNodeMap.count(formatKey(secondIndex, thirdIndex))) {\r\n                        // 第二条边不存在\r\n                        continue;\r\n                    }\r\n                    if (not tradeNodeMap.count(formatKey(thirdIndex, originIndex))) {\r\n                        // 第三条边不存在\r\n                        continue;\r\n                    }\r\n\r\n                    auto triangular = new Triangular{\r\n                        .Steps = {originIndex, secondIndex, thirdIndex, originIndex}\r\n                    };\r\n                    auto steps = triangular->Steps;\r\n                    triangularMap[originIndex].emplace_back(triangular);\r\n\r\n                    for (int i = 0; i < steps.size() - 1; i++){\r\n                        u_int64_t key = formatKey(steps[i], steps[i + 1]);\r\n                        relatedTriangular[key].emplace_back(triangular);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // 存储所有一步、两步路径\r\n        for (const auto& origin : indexToToken)\r\n        {\r\n            auto originIndex = origin.first; // 起点\r\n            for (const auto& second : indexToToken)\r\n            {\r\n                auto secondIndex = second.first; // 第二个点\r\n                if (not tradeNodeMap.count(formatKey(originIndex, secondIndex))) {\r\n                    // 第一条边不存在\r\n                    continue;\r\n                }\r\n\r\n                // 存储一步路径\r\n                auto onePath = new Path{\r\n                    .StepCount = 1,\r\n                    .Steps = vector<int>{originIndex, secondIndex}\r\n                };\r\n                pathMap[formatKey(originIndex, secondIndex)].emplace_back(onePath);\r\n\r\n                for (const auto& third : indexToToken)\r\n                {\r\n                    auto thirdIndex = third.first; // 第三个点\r\n                    if (not tradeNodeMap.count(formatKey(secondIndex, thirdIndex)))\r\n                    {\r\n                        // 第二条边不存在\r\n                        continue;\r\n                    }\r\n\r\n                    // 存储两步路径\r\n                    auto twoPath = new Path{\r\n                            .StepCount = 2,\r\n                            .Steps = vector<int>{originIndex, secondIndex, thirdIndex}\r\n                    };\r\n                    pathMap[formatKey(originIndex, thirdIndex)].emplace_back(twoPath);\r\n                    // 存储交易对价格波动会影响的路径\r\n                    relatedPath[formatKey(originIndex, secondIndex)].insert(twoPath);\r\n                    relatedPath[formatKey(secondIndex, thirdIndex)].insert(twoPath);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    void Graph::UpdateNode(WebsocketWrapper::DepthData &data)\r\n    {\r\n        auto baseIndex = tokenToIndex[data.BaseToken];\r\n        auto quoteIndex = tokenToIndex[data.QuoteToken];\r\n\r\n        auto node = tradeNodeMap[formatKey(baseIndex, quoteIndex)];\r\n        if (not data.Bids.empty())\r\n        { // 买单挂出价，我方卖出价\r\n            auto depth = data.Bids[0];\r\n            node->UpdateSell(depth.Price, depth.Quantity);\r\n        }\r\n        if (!data.Asks.empty())\r\n        { // 卖单挂出价，我方买入价\r\n            auto depth = data.Asks[0];\r\n            node->UpdateBuy(depth.Price, depth.Quantity);\r\n        }\r\n\r\n        if (define::IsStableCoin(data.BaseToken)){\r\n            int updateNum = updateBestMap(tokenToIndex[data.QuoteToken], tokenToIndex[data.BaseToken]);\r\n        }\r\n        if (define::IsStableCoin(data.QuoteToken)) {\r\n            int updateNum = updateBestMap(tokenToIndex[data.BaseToken], tokenToIndex[data.QuoteToken]);\r\n        }\r\n\r\n        if (not conf::EnableMock || this->mockSubscriber == nullptr)\r\n            return;\r\n\r\n        // 触发mock\r\n        double sellPrice = node->GetOriginPrice(baseIndex, quoteIndex);\r\n        double buyPrice = node->GetOriginPrice(quoteIndex, baseIndex);\r\n        this->mockSubscriber(data.BaseToken, data.QuoteToken, buyPrice, sellPrice);\r\n\r\n        /*auto chance = CalculateArbitrage(conf::MakerTriangular, baseIndex, quoteIndex);\r\n        if (chance.Profit <= 1)\r\n        {\r\n            return;\r\n        }\r\n\r\n        spdlog::info(\"func: {}, path found profit: {}\", \"UpdateNode\", chance.Profit);\r\n\r\n        return this->subscriber(chance);*/\r\n    }\r\n\r\n    int Graph::updateBestMap(int from, int to){\r\n        int updateNum = 0, newNum = 0;\r\n        for (auto path : relatedPath[formatKey(from, to)]){\r\n            u_int64_t key = formatKey(path->Steps[0], path->Steps[path->Steps.size()-1]);\r\n            double currentProfit = calculateMakerPathProfit(path->Steps);\r\n            if (currentProfit == 0){\r\n                continue;\r\n            }\r\n\r\n            // 首次插入最佳路径\r\n            if (not bestPathMap.count(key)) {\r\n                bestPathMap[key].push_back({path->Steps, currentProfit});\r\n                newNum++;\r\n            }\r\n            // 如果本路径本就是最优路径则更新profit\r\n            else {\r\n                list<BestPath>::iterator p;\r\n                auto bestPaths = bestPathMap[key];\r\n\r\n                // 如果当前路径已被记录就删除，之后重新插入\r\n                for(p = bestPaths.begin(); p != bestPaths.end(); p++){\r\n                    if (path->Steps == p->bestPath){\r\n                        bestPaths.erase(p);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // 插入路径\r\n                for(p = bestPaths.begin(); p != bestPaths.end(); p++) {\r\n                    if (p->profit < currentProfit) {\r\n                        bestPaths.insert(p, {path->Steps, currentProfit});\r\n                    }\r\n                }\r\n                if (p == bestPaths.end()) {\r\n                    bestPaths.insert(p, {path->Steps, currentProfit});\r\n                }\r\n            }\r\n        }\r\n\r\n        /*spdlog::debug(\"func: {}, {}->{}, Path Num: {}, New Num: {}, Update Num: {}\",\r\n                \"updateBestMap\",\r\n                from,\r\n                to,\r\n                relatedPath[formatKey(from, to)].size(),\r\n                newNum,\r\n                updateNum);*/\r\n        return updateNum;\r\n    }\r\n\r\n    // 目前的特殊逻辑，之后改成通用逻辑\r\n    double Graph::calculateMakerPathProfit(vector<int>& path){\r\n        double currentProfit = 1; // 验算利润率\r\n        for (int i = 0; i < path.size() - 1; i++)\r\n        {\r\n            auto from = path[i];\r\n            auto to = path[i + 1];\r\n\r\n            auto node = tradeNodeMap[formatKey(from, to)];\r\n            if (node == NULL){\r\n                return 0;\r\n            }\r\n\r\n            currentProfit = currentProfit * node->GetParsePrice(from, to);\r\n        }\r\n        currentProfit = currentProfit*(1-0.0004);\r\n        return currentProfit;\r\n    }\r\n\r\n    int Graph::GetExchangePrice(GetExchangePriceReq &req, GetExchangePriceResp &resp)\r\n    {\r\n        if (not tokenToIndex.count(req.BaseToken) || not tokenToIndex.count(req.QuoteToken)) {\r\n            return define::ErrorGraphNotReady;\r\n        }\r\n\r\n        int baseIndex = tokenToIndex[req.BaseToken];\r\n        int quoteIndex = tokenToIndex[req.QuoteToken];\r\n\r\n        auto node = tradeNodeMap[formatKey(baseIndex, quoteIndex)];\r\n        resp.SellPrice = node->GetOriginPrice(baseIndex, quoteIndex);\r\n        resp.SellQuantity = node->GetQuantity(baseIndex, quoteIndex);\r\n        resp.BuyPrice = node->GetOriginPrice(quoteIndex, baseIndex);\r\n        resp.BuyQuantity = node->GetQuantity(quoteIndex, baseIndex);\r\n\r\n        // maker不可下单到对手盘\r\n        auto symbolData = apiWrapper.GetSymbolData(req.BaseToken, req.QuoteToken);\r\n        if (req.OrderType == define::LIMIT_MAKER) {\r\n            resp.SellPrice = resp.SellPrice + symbolData.TicketSize;\r\n        }\r\n        if (req.OrderType == define::LIMIT_MAKER) {\r\n            resp.BuyPrice = resp.BuyPrice - symbolData.TicketSize;\r\n        }\r\n\r\n        if (resp.SellPrice == 0 || resp.BuyPrice == 0) {\r\n            return define::ErrorGraphNotReady;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    ArbitrageChance Graph::CalculateArbitrage(conf::Strategy& strategy, int baseIndex, int quoteIndex) {\r\n        double maxProfit = 0;\r\n        vector<TransactionPathItem> resultPath{};\r\n\r\n        struct timeval tv1, tv2;\r\n        gettimeofday(&tv1,NULL);\r\n\r\n        for (auto item: relatedTriangular[formatKey(quoteIndex, baseIndex)]){\r\n//            spdlog::debug(\"func: {}, before calculate profit, ring:{}->{}->{}\", \"CalculateArbitrage\", item->Steps[0], item->Steps[1], item->Steps[2]);\r\n            double profit = calculateProfit(strategy, 1, item->Steps);\r\n//            spdlog::debug(\"func: {}, after calculate profit, profit: {}, max profit: {}\", \"CalculateArbitrage\", profit, maxProfit);\r\n            if (profit <= 1 || profit <= maxProfit)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            auto path = formatPath(strategy, 1, item->Steps);\r\n            adjustQuantities(path);\r\n            if (not checkPath(path))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            maxProfit = profit;\r\n            resultPath = path;\r\n            spdlog::info(\"func: {}, update max profit, profit: {}, max profit: {}\", \"CalculateArbitrage\", profit, maxProfit);\r\n        }\r\n        gettimeofday(&tv2,NULL);\r\n\r\n        /*spdlog::debug(\"func: {}, scan rings: {}, path time cost: {}us, max profit: {}\",\r\n                \"CalculateArbitrage\",\r\n                relatedTriangular[formatKey(quoteIndex, baseIndex)].size(),\r\n                tv2.tv_sec*1000000 + tv2.tv_usec - (tv1.tv_sec*1000000 + tv1.tv_usec),\r\n                maxProfit);*/\r\n\r\n        ArbitrageChance chance{};\r\n        if (resultPath.size() != 3) {\r\n            return chance;\r\n        }\r\n\r\n        chance.Profit = maxProfit;\r\n        chance.Quantity = resultPath.front().Quantity;\r\n        chance.Path = resultPath;\r\n        return chance;\r\n    }\r\n\r\n    ArbitrageChance Graph::FindBestPath(FindBestPathReq& req) {\r\n        int originToken = tokenToIndex[req.Origin];\r\n        int endToken = tokenToIndex[req.End];\r\n\r\n        double profit = 0;\r\n        vector<TransactionPathItem> resultPath{};\r\n        auto item = bestPathMap[formatKey(originToken, endToken)];\r\n        list<BestPath>::iterator p1;\r\n        for (p1 = item.begin(); p1 != item.end(); p1++) {\r\n            resultPath = formatPath(req.Strategy, req.Phase, p1->bestPath);\r\n            if (resultPath.empty()) {\r\n                continue;\r\n            }\r\n            adjustQuantities(resultPath);\r\n            if (not checkPath(resultPath)) {\r\n                continue;\r\n            }\r\n            // 找到利润率最大的有效路径\r\n            profit = p1->profit;\r\n            break;\r\n        }\r\n\r\n        // 找完了都没找到有效路径\r\n        ArbitrageChance chance{};\r\n        if (p1 == item.end()){\r\n            return chance;\r\n        }\r\n\r\n        auto pathPrice = resultPath.front().Price;\r\n        auto pathQuantity = resultPath.front().Quantity;\r\n\r\n        auto quantity = req.Quantity;\r\n        if (resultPath.front().Side == define::BUY) {\r\n            quantity /= pathPrice; // 转换成baseToken数量\r\n        }\r\n        double realQuantity = RoundDouble(Min(quantity, pathQuantity));\r\n\r\n        resultPath.front().Quantity = realQuantity;\r\n        chance.Profit = profit;\r\n        chance.Quantity = realQuantity;\r\n        chance.Path = resultPath;\r\n        return chance;\r\n    }\r\n\r\n    vector<TransactionPathItem> Graph::formatPath(conf::Strategy& strategy, int phase, vector<int>& path)\r\n    {\r\n        vector<TransactionPathItem> result;\r\n        if (path.size() < 2)\r\n        {\r\n            return result;\r\n        }\r\n\r\n        for (int i = 0; i < path.size() - 1; i++)\r\n        {\r\n            auto from = path[i];\r\n            auto to = path[i + 1];\r\n\r\n            auto node = tradeNodeMap[formatKey(from, to)];\r\n            result.emplace_back(node->Format(strategy.GetStep(phase+i), indexToToken, from, to));\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    bool Graph::checkPath(vector<TransactionPathItem>& path)\r\n    {\r\n        for (TransactionPathItem& item : path)\r\n        {\r\n            // 检查最小成交金额\r\n            auto symbolData = apiWrapper.GetSymbolData(item.BaseToken, item.QuoteToken);\r\n            if (symbolData.MinNotional > item.GetNationalQuantity())\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (path.front().Quantity < conf::MinTriangularQuantity)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    double Graph::calculateProfit(conf::Strategy& strategy, int phase, vector<int>& path)\r\n    {\r\n        if (path.size() < 2)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        double profit = 1; // 验算利润率\r\n        for (int i = 0; i < path.size() - 1; i++)\r\n        {\r\n            auto from = path[i];\r\n            auto to = path[i + 1];\r\n\r\n            auto node = tradeNodeMap[formatKey(from, to)];\r\n            profit = profit * node->GetParsePrice(from, to) * strategy.GetFee(phase);\r\n        }\r\n\r\n        return profit;\r\n    }\r\n\r\n    u_int64_t Graph::formatKey(int from, int to)\r\n    {\r\n        u_int64_t result = u_int64_t(from) << 32 | to;\r\n        return result;\r\n    }\r\n\r\n    void Graph::adjustQuantities(vector<TransactionPathItem>& items) {\r\n        double cumQuantity = items[0].Quantity;\r\n        // spdlog::info(\"token: {}, quantity: {}\", items[0].Quantity, cumQuantity);\r\n        for (int i = 0; i < items.size(); i++) {\r\n            // 获取第i项以前的累加数量\r\n            auto &curItem = items[i];\r\n            // 判断第i项容量\r\n            if (cumQuantity <= curItem.Quantity) {\r\n                // 容量足够，直接赋值\r\n                curItem.Quantity = cumQuantity;\r\n                if (curItem.Side == define::SELL) {\r\n                    cumQuantity = curItem.Quantity*curItem.Price;\r\n                } else {\r\n                    cumQuantity = curItem.Quantity/curItem.Price;\r\n                }\r\n                // spdlog::info(\"i: {}, token: {}, over, newQuantity: {}\", i, curItem.GetFromToken()+curItem.GetToToken(), curItem.Quantity);\r\n            } else {\r\n                // 容量不足，逆推数量\r\n                // spdlog::info(\"i: {}, token: {}, less, need: {}, have: {}\", i, curItem.GetFromToken()+curItem.GetToToken(), cumQuantity, curItem.Quantity);\r\n                cumQuantity = curItem.Quantity;\r\n                double reverseCumQuantity = curItem.Quantity;\r\n                for (int k = i - 1; k >= 0; k--) {\r\n                    if (items[k].Side == define::SELL) {\r\n                        reverseCumQuantity /= items[k].Price;\r\n                        items[k].Quantity = reverseCumQuantity;\r\n                    } else {\r\n                        reverseCumQuantity *= items[k].Price;\r\n                        items[k].Quantity = reverseCumQuantity;\r\n                    }\r\n                    // spdlog::info(\"k: {}, token: {}, newQuantity: {}\", k, items[k].GetFromToken()+items[k].GetToToken(), items[k].Quantity);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    void Graph::SubscribeArbitrage(function<void(ArbitrageChance &path)> handler)\r\n    {\r\n        this->subscriber = handler;\r\n    }\r\n\r\n    void Graph::SubscribeMock(function<void(const string& base, string quote, double buyPrice, double sellPrice)> handler){\r\n        this->mockSubscriber = handler;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/pathfinder/graph.cpp	(revision b9986d1c989c818c4038fc5a3b145e28528cf0b3)
+++ lib/pathfinder/graph.cpp	(date 1679039578061)
@@ -140,13 +140,11 @@
         auto node = tradeNodeMap[formatKey(baseIndex, quoteIndex)];
         if (not data.Bids.empty())
         { // 买单挂出价，我方卖出价
-            auto depth = data.Bids[0];
-            node->UpdateSell(depth.Price, depth.Quantity);
+            node->UpdateSell(data.Bids);
         }
         if (!data.Asks.empty())
         { // 卖单挂出价，我方买入价
-            auto depth = data.Asks[0];
-            node->UpdateBuy(depth.Price, depth.Quantity);
+            node->UpdateBuy(data.Asks);
         }
 
         if (define::IsStableCoin(data.BaseToken)){
